DddCompact = function(domains, events) {    var application = {        namespaces: {},        domains: {},        eventBus: null,        loader: null,        utilities: null,        id: 1    };    application.init = function(domains, events) {        application.utilities = new application.Utilities();        application.eventBus = new application.EventBus({            makeItemMethod: application.makeItem,            events: events,            utilities: application.utilities        });        application.loader = new application.Loader();        application.utilities.object.each(domains, function(domainName, url) {            application.namespaces[domainName] = {};            application.loader.loadScript(                url,                 application.namespaces[domainName]            );                    });                return {            makeItem: application.makeItem        }    };    application.makeItem = function(domainName, itemClass, itemOptions) {            var domain = application.makeDomain(domainName);                var item = domain.makeItem(itemClass, itemOptions);            return item;    };        application.makeDomain = function(domainName) {            if (!application.namespaces[domainName]) {            throw new Error("No namespace has been defined for " + domainName + " domain");        }        if (!application.domains[domainName]) {            application.domains[domainName] = new application.Domain({                domainName: domainName,                namespace: application.namespaces[domainName],                eventBus: application.eventBus,                utilities: application.utilities,                provideIdMethod: application.provideId            });        }                return application.domains[domainName];        };    application.provideId = function() {                return application.id++;            }        application.Domain = function(domainOptions) {        var domain = {            factory: null        };        domain.init = function(domainOptions) {                        domain.factory = new domain.Factory({                domainName: domainOptions.domainName,                namespace: domainOptions.namespace,                eventBus: domainOptions.eventBus,                utilities: domainOptions.utilities,                provideIdMethod: domainOptions.provideIdMethod            });            return  {                makeItem: domain.makeItem            }                    };        domain.makeItem = function(className, itemOptions) {                    var compound = domain.factory.makeItem(className, itemOptions);                        return compound.item;                    }                domain.Factory = function(factoryOptions) {            var factory = {                domainName: null,                namespace: null,                eventBus: null,                utilities: null,                cores: []            };                        factory.init = function(factoryOptions) {                                factory.domainName = factoryOptions.domainName;                factory.namespace = factoryOptions.namespace;                factory.eventBus = factoryOptions.eventBus;                factory.utilities = factoryOptions.utilities;                factory.provideIdMethod = factoryOptions.provideIdMethod;                                return {                    makeItem: factory.makeItem,                    makeCollection: factory.makeCollection                };            };                        factory.provideIdMethod = function() {};                        factory.makeCore = function(itemClass, itemOptions) {                var core = new domain.Core({                    factory: factory,                    utilities: factory.utilities,                    domainName: factory.domainName,                    itemClass: itemClass,                    id: factory.provideIdMethod(),                    itemOptions: itemOptions,                    fireEventMethod: factory.makeFiringMethod(itemClass),                    makeCollectionMethod: factory.makeCollection                });                                factory.cores.push(core);                                return core;                            };                        factory.makeItem = function(itemClass, itemOptions) {                if (typeof itemOptions == "undefined") {                    itemOptions = {};                }                            var core = factory.makeCore(itemClass, itemOptions);                var item = new factory.namespace[itemClass](core);                                core.finishDefinition(item);                return {                    item: item,                    core: core                };                            };                        factory.findCore = function(item) {                for (var i in factory.cores) {                                        if (factory.cores[i].hasItem(item)) {                        return factory.cores[i];                    }                                    }                                return null;                            };                        factory.makeCollection = function(itemClass) {                            var collection = new domain.Collection({                    eventBus: factory.eventBus,                    utilities: factory.utilities,                    itemFactoryMethod: function(record) {                        return factory.makeItem(itemClass, record);                    },                    findCoreMethod: function(item) {                        return factory.findCore(item);                    },                    fireEventMethod: factory.makeFiringMethod(itemClass)                });                                return collection;                            };            factory.makeFiringMethod = function(itemClass) {                return function(eventName, eventData) {                    if (typeof eventData == 'undefined') {                        var eventData = {};                    }                    eventData.domainName = factory.domainName;                    eventData.itemClass = itemClass;                    return factory.eventBus.fireEvent(eventName, eventData);                };                            };                        return factory.init(factoryOptions);                    };        domain.Core = function(coreOptions) {            var core = {                itemOptions: null,                id: null,                utilities: null,                domainName: null,                itemClass: null,                host: null,                idFieldName: null,                fieldNames: [],                requiredFieldNames: [],                item: null,                publicMembers: {}            };            core.init = function(coreOptions) {                core.itemOptions = coreOptions.itemOptions;                core.id = coreOptions.id;                core.makeCollectionMethod = coreOptions.makeCollectionMethod;                core.fireEventMethod = coreOptions.fireEventMethod;                core.utilities = coreOptions.utilities;                core.domainName = coreOptions.domainName;                core.itemClass = coreOptions.itemClass;                core.publicMembers = {                    isIn: core.isIn,                    defineIdField: core.defineIdField,                    defineField: core.defineField,                    defineRequiredField: core.defineRequiredField,                    defineCollection: core.defineCollection,                    defineMessages: core.defineMessages,                    defineEvents: core.defineEvents,                    defineUtilities: core.defineUtilities,                    finishDefinition: core.finishDefinition                };                                return core.publicMembers;            };                        core.makeCollectionMethod = function() {};                        core.fireEventMethod = function() {};            core.isIn = function(host) {                core.host = host;                            };                        core.defineIdField = function(idFieldName) {                core.defineField(idFieldName);                core.idFieldName = idFieldName;            };            core.defineRequiredField = function(requiredFieldName) {                                core.defineField(requiredFieldName);                core.requiredFieldNames.push(requiredFieldName);                                if (typeof core.itemOptions[requiredFieldName] == 'undefined') {                    throw new Error(                        'When creating '                        + core.domainName                        + '.'                        + core.itemClass                        + ' objects you must provide a value for the "'                        + requiredFieldName                        + '" field.'                    );                }                            }                        core.defineField = function(fieldName, defaultValue) {                            if (typeof defaultValue == "undefined") {                    defaultValue = null;                }                                var fieldValue = defaultValue;                            if (core.fieldNames[fieldName]) {                    throw new Error(                        "Field "                         + core.domainName                        + "." + core.itemClass                         + "." + fieldName                         + " cannot be redefined."                    );                }                                core.fieldNames.push(fieldName);                if (typeof core.itemOptions[fieldName] !== 'undefined') {                    fieldValue = core.itemOptions[fieldName];                }                            core.addHostMember(fieldName, fieldValue);                            };            core.defineCollection = function(collectionName, collectionClass) {                            var collection = core.makeCollectionMethod(collectionClass);                core.addHostMember(collectionName, collection);                            };                        core.defineMessages = function() {                                var messageNames = arguments;                                for (var i in messageNames) {                    core.addHostMember(messageNames[i], function(data) {                                            });                }                            };                        core.defineEvents = function() {                                var eventNames = arguments;                                var factory = function(eventName) {                    return function (data) {                        return core.fireEventMethod(eventName, data);                    }                }                                for (var i in eventNames) {                    core.addHostMember(eventNames[i], factory(eventNames[i]));                }                            };            core.defineUtilities = function(name) {                                if (typeof name == "undefined") {                    name = "utilities";                }                                core.addHostMember(name, core.utilities);                            };                        core.finishDefinition = function(item) {                core.item = item;                            delete(core.publicMembers.isIn);                delete(core.publicMembers.defineIdField);                delete(core.publicMembers.defineRequiredField);                delete(core.publicMembers.defineField);                delete(core.publicMembers.defineCollection);                                core.publicMembers.hasItem = core.hasItem;                core.publicMembers.getRecord = core.getRecord;                core.publicMembers.getIdFieldName = core.getIdFieldName;                        };                        core.hasItem = function(item) {                return (item === core.item);                            }                        core.getRecord = function() {                                var record = {};                                for (var i in core.fieldNames) {                                        record[core.fieldNames[i]] = core.host[core.fieldNames[i]];                                    }                                return record;                            }                        core.getIdFieldName = function() {                return core.idFieldName;            }                        core.addHostMember = function(key, value) {                if (typeof core.host[key] !== "undefined") {                    throw new Error(                        "The internal member "                         + core.domainName                        + "." + core.itemClass                         + "." + key                         + " cannot be redefined."                    );                }                                core.host[key] = value;                            };                        return core.init(coreOptions);        };        domain.Collection = function(collectionOptions) {            var collection = {                eventBus: null,                utilities: null            };            collection.init = function(collectionOptions) {                collection.eventBus = collectionOptions.eventBus;                collection.utilities = collectionOptions.utilities;                collection.itemFactoryMethod = collectionOptions.itemFactoryMethod;                collection.fireEventMethod = collectionOptions.fireEventMethod;                collection.findCoreMethod = collectionOptions.findCoreMethod;                                return {                    createItem: collection.createItem,                    readAllItems: collection.readAllItems,                    readItemUsingId: collection.readItemUsingId,                    updateItem: collection.updateItem,                    deleteItem: collection.deleteItem                };            };                        collection.itemFactoryMethod = function() {};                        collection.findCoreMethod = function() {};                        collection.fireEventMethod = function() {};                        collection.createItem = function(requiredValues) {                                if (typeof requiredValues == "undefined") {                    var requiredValues = {};                }                                var compound = collection.itemFactoryMethod(requiredValues);                return compound.item;                            };            collection.readAllItems = function() {                var records = collection.fireEventMethod("readAllRecords", {}, []);                return collection.turnToItems(records);                            };                        collection.readItemUsingId = function(id) {            };            collection.updateItem = function(item) {                                var core = collection.findCoreMethod(item);                if (!core) {                    return;                }                                var idFieldName = core.getIdFieldName();                var record = core.getRecord();                                if (!record[idFieldName]) {                    collection.fireEventMethod("setRecordId", {                        idFieldName: idFieldName,                        record: record                    });                }                                collection.fireEventMethod("updateRecord", {                    idFieldName: idFieldName,                    record: record                });                            };            collection.deleteItem = function(item) {                var core = collection.findCoreMethod(item);                if (!core) {                    return;                }                                var idFieldName = core.getIdFieldName();                var record = core.getRecord();                                collection.fireEventMethod("deleteRecord", {                    idFieldName: idFieldName,                    idFieldValue: record[idFieldName]                });                                delete(item);                delete(core);            };                        collection.turnToItems = function(records) {                                var items = [];                                for (var i in records) {                    items.push(collection.turnToItem(records[i]));                }                                return items;                            };                        collection.turnToItem = function(record) {                var compound = collection.itemFactoryMethod(record);                                return compound.item;                            };                        return collection.init(collectionOptions);        };        return domain.init(domainOptions);    };    application.EventBus = function(eventBusOptions) {            var eventBus = {            singletons: {},            events: null,            utilities: null        };        eventBus.init = function(eventBusOptions) {                        eventBus.makeItemMethod = eventBusOptions.makeItemMethod;            eventBus.events = eventBusOptions.events ? eventBusOptions.events : {};            eventBus.utilities = eventBusOptions.utilities;                        return {                fireEvent: eventBus.fireEvent            };                    };                eventBus.makeItemMethod = function(){};                eventBus.fireEvent = function(eventName, eventData, defaultResult) {            console.log(                'Domain '                + eventData.domainName                 + '.'                + eventData.itemClass                + ' fired "'                 + eventName                + '" event with this data:'            );            console.log(eventData);            if (eventBus.events[eventName]) {                return eventBus.events[eventName](eventData, eventBus, eventBus.utilities);            } else {                return defaultResult;            }                    };                eventBus.makeItem = function(domainName, itemClass) {                        return eventBus.makeItemMethod(domainName, itemClass);                    }                eventBus.makeSingleton = function(domainName, itemClass) {                        if (!eventBus.singletons[domainName]) {                eventBus.singletons[domainName] = {};            }                        if (!eventBus.singletons[domainName][itemClass]) {                eventBus.singletons[domainName][itemClass] = eventBus.makeItemMethod(domainName, itemClass);            }                        return eventBus.singletons[domainName][itemClass];                    }                return eventBus.init(eventBusOptions);            }        application.Utilities = function() {                var utilities = {};        utilities.init = function() {            return {                object: utilities.object,                array: utilities.array,                test: utilities.test            };                    }                utilities.object = {};        utilities.object.each = function(object, fn, scope) {        /**        * Iterates through an object and invokes the given callback function for each iteration.        * The iteration can be stopped by returning `false` in the callback function. For example:        *        *     var person = {        *         name: 'Jacky'        *         hairColor: 'black'        *         loves: ['food', 'sleeping', 'wife']        *     };        *        *     Ext.Object.each(person, function(key, value, myself) {        *         console.log(key + ":" + value);        *        *         if (key === 'hairColor') {        *             return false; // stop the iteration        *         }        *     });        *        * @param {Object} object The object to iterate        * @param {Function} fn The callback function.        * @param {String} fn.key        * @param {Object} fn.value        * @param {Object} fn.object The object itself        * @param {Object} [scope] The execution scope (`this`) of the callback function        */            for (var property in object) {                if (object.hasOwnProperty(property)) {                    if (fn.call(scope || object, property, object[property], object) === false) {                        return;                    }                }            }        };        utilities.object.clone = function(item) {        /**         * Clone almost any type of variable including array, object, DOM nodes and Date without keeping the old reference         * @param {Object} item The variable to clone         * @return {Object} clone         */                        if (item === null || item === undefined) {                return item;            }            // DOM nodes            // TODO proxy this to Ext.Element.clone to handle automatic id attribute changing            // recursively            if (item.nodeType && item.cloneNode) {                return item.cloneNode(true);            }            var type = toString.call(item);            // Date            if (type === '[object Date]') {                return new Date(item.getTime());            }            var i, j, k, clone, key;            // Array            if (type === '[object Array]') {                i = item.length;                clone = [];                while (i--) {                    clone[i] = utilities.object.clone(item[i]);                }            }            // Object            else if (type === '[object Object]' && item.constructor === Object) {                clone = {};                for (key in item) {                    clone[key] = utilities.object.clone(item[key]);                }                if (enumerables) {                    for (j = enumerables.length; j--;) {                        k = enumerables[j];                        clone[k] = item[k];                    }                }            }            return clone || item;        };        utilities.object.apply = function(object, config, defaults) {        /**         * Copies all the properties of config to the specified object.         * Note that if recursive merging and cloning without referencing the original objects / arrays is needed, use         * {@link Ext.Object#merge} instead.         * @param {Object} object The receiver of the properties         * @param {Object} config The source of the properties         * @param {Object} defaults A different object that will also be applied for default values         * @return {Object} returns obj         */            if (defaults) {                utilities.object.apply(object, defaults);            }            if (object && config && typeof config === 'object') {                var i, j, k;                for (i in config) {                    object[i] = config[i];                }                if (enumerables) {                    for (j = enumerables.length; j--;) {                        k = enumerables[j];                        if (config.hasOwnProperty(k)) {                            object[k] = config[k];                        }                    }                }            }            return object;        }        utilities.object.merge = function(source, key, value) {        /**         * Merges any number of objects recursively without referencing them or their children.         *         *     var extjs = {         *         companyName: 'Ext JS',         *         products: ['Ext JS', 'Ext GWT', 'Ext Designer'],         *         isSuperCool: true         *         office: {         *             size: 2000,         *             location: 'Palo Alto',         *             isFun: true         *         }         *     };         *         *     var newStuff = {         *         companyName: 'Sencha Inc.',         *         products: ['Ext JS', 'Ext GWT', 'Ext Designer', 'Sencha Touch', 'Sencha Animator'],         *         office: {         *             size: 40000,         *             location: 'Redwood City'         *         }         *     };         *         *     var sencha = Ext.Object.merge(extjs, newStuff);         *         *     // extjs and sencha then equals to         *     {         *         companyName: 'Sencha Inc.',         *         products: ['Ext JS', 'Ext GWT', 'Ext Designer', 'Sencha Touch', 'Sencha Animator'],         *         isSuperCool: true         *         office: {         *             size: 30000,         *             location: 'Redwood City'         *             isFun: true         *         }         *     }         *         * @param {Object...} object Any number of objects to merge.         * @return {Object} merged The object that is created as a result of merging all the objects passed in.         */            if (typeof key === 'string') {                if (value && value.constructor === Object) {                    if (source[key] && source[key].constructor === Object) {                        utilities.object.merge(source[key], value);                    }                    else {                        source[key] = utilities.object.clone(value);                    }                }                else {                    source[key] = value;                }                return source;            }            var i = 1,                ln = arguments.length,                object, property;            for (; i < ln; i++) {                object = arguments[i];                for (property in object) {                    if (object.hasOwnProperty(property)) {                        utilities.object.merge(source, property, object[property]);                    }                }            }            return source;        }        utilities.array = {};        utilities.array.indexOf = function(array, item, from) {        /**         * Get the index of the provided `item` in the given `array`, a supplement for the         * missing arrayPrototype.indexOf in Internet Explorer.         *         * @param {Array} array The array to check         * @param {Object} item The item to look for         * @param {Number} from (Optional) The index at which to begin the search         * @return {Number} The index of item in the array (or -1 if it is not found)         */                    if ('indexOf' in Array.prototype) {                return array.indexOf(item, from);            }            var i, length = array.length;            for (i = (from < 0) ? Math.max(0, length + from) : from || 0; i < length; i++) {                if (array[i] === item) {                    return i;                }            }            return -1;        };        utilities.array.contains = function(array, item) {        /**         * Checks whether or not the given `array` contains the specified `item`         *         * @param {Array} array The array to check         * @param {Object} item The item to look for         * @return {Boolean} True if the array contains the item, false otherwise         */                        if ('indexOf' in Array.prototype) {                return array.indexOf(item) !== -1;            }            var i, ln;            for (i = 0, ln = array.length; i < ln; i++) {                if (array[i] === item) {                    return true;                }            }            return false;                    }        utilities.array.clone = function(array) {        /**         * Clone a flat array without referencing the previous one. Note that this is different         * from Ext.clone since it doesn't handle recursive cloning. It's simply a convenient, easy-to-remember method         * for Array.prototype.slice.call(array)         *         * @param {Array} array The array         * @return {Array} The clone array         */                    return slice.call(array);                    };        utilities.array.map = function(array, fn, scope) {        /**         * Creates a new array with the results of calling a provided function on every element in this array.         *         * @param {Array} array         * @param {Function} fn Callback function for each item         * @param {Object} scope Callback function scope         * @return {Array} results         */                    if ('map' in Array.prototype) {                return array.map(fn, scope);            }            var results = [],                i = 0,                len = array.length;            for (; i < len; i++) {                results[i] = fn.call(scope, array[i], i, array);            }            return results;                    };        utilities.array.merge = function() {        /**         * Merge multiple arrays into one with unique items.         *         * {@link Ext.Array#union} is alias for {@link Ext.Array#merge}         *         * @param {Array} array1         * @param {Array} array2         * @param {Array} etc         * @return {Array} merged         */                    var args = slice.call(arguments),                array = [],                i, ln;            for (i = 0, ln = args.length; i < ln; i++) {                array = array.concat(args[i]);            }            return utilities.array.unique(array);        };        utilities.array.intersect = function() {        /**         * Merge multiple arrays into one with unique items that exist in all of the arrays.         *         * @param {Array} array1         * @param {Array} array2         * @param {Array} etc         * @return {Array} intersect         */                        var intersect = [],                arrays = slice.call(arguments),                i, j, k, minArray, array, x, y, ln, arraysLn, arrayLn;            if (!arrays.length) {                return intersect;            }            // Find the smallest array            for (i = x = 0,ln = arrays.length; i < ln,array = arrays[i]; i++) {                if (!minArray || array.length < minArray.length) {                    minArray = array;                    x = i;                }            }            minArray = utilities.array.unique(minArray);            erase(arrays, x, 1);            // Use the smallest unique'd array as the anchor loop. If the other array(s) do contain            // an item in the small array, we're likely to find it before reaching the end            // of the inner loop and can terminate the search early.            for (i = 0,ln = minArray.length; i < ln,x = minArray[i]; i++) {                var count = 0;                for (j = 0,arraysLn = arrays.length; j < arraysLn,array = arrays[j]; j++) {                    for (k = 0,arrayLn = array.length; k < arrayLn,y = array[k]; k++) {                        if (x === y) {                            count++;                            break;                        }                    }                }                if (count === arraysLn) {                    intersect.push(x);                }            }            return intersect;        };        utilities.array.difference = function(arrayA, arrayB) {        /**         * Perform a set difference A-B by subtracting all items in array B from array A.         *         * @param {Array} arrayA         * @param {Array} arrayB         * @return {Array} difference         */                        var clone = slice.call(arrayA),                ln = clone.length,                i, j, lnB;            for (i = 0,lnB = arrayB.length; i < lnB; i++) {                for (j = 0; j < ln; j++) {                    if (clone[j] === arrayB[i]) {                        erase(clone, j, 1);                        j--;                        ln--;                    }                }            }            return clone;        };        utilities.array.min = function(array, comparisonFn) {        /**         * Returns the minimum value in the Array.         *         * @param {Array/NodeList} array The Array from which to select the minimum value.         * @param {Function} comparisonFn (optional) a function to perform the comparision which determines minimization.         * If omitted the "<" operator will be used. Note: gt = 1; eq = 0; lt = -1         * @return {Object} minValue The minimum value         */                    var min = array[0],                i, ln, item;            for (i = 0, ln = array.length; i < ln; i++) {                item = array[i];                if (comparisonFn) {                    if (comparisonFn(min, item) === 1) {                        min = item;                    }                }                else {                    if (item < min) {                        min = item;                    }                }            }            return min;        };        utilities.array.max = function(array, comparisonFn) {        /**         * Returns the maximum value in the Array.         *         * @param {Array/NodeList} array The Array from which to select the maximum value.         * @param {Function} comparisonFn (optional) a function to perform the comparision which determines maximization.         * If omitted the ">" operator will be used. Note: gt = 1; eq = 0; lt = -1         * @return {Object} maxValue The maximum value         */                        var max = array[0],                i, ln, item;            for (i = 0, ln = array.length; i < ln; i++) {                item = array[i];                if (comparisonFn) {                    if (comparisonFn(max, item) === -1) {                        max = item;                    }                }                else {                    if (item > max) {                        max = item;                    }                }            }            return max;        };        utilities.array.unique = function(array) {        /**         * Returns a new array with unique items         *         * @param {Array} array         * @return {Array} results         */                    var clone = [],                i = 0,                ln = array.length,                item;            for (; i < ln; i++) {                item = array[i];                if (utilities.array.indexOf(clone, item) === -1) {                    clone.push(item);                }            }            return clone;        };        utilities.array.filter = function(array, fn, scope) {        /**         * Creates a new array with all of the elements of this array for which         * the provided filtering function returns true.         *         * @param {Array} array         * @param {Function} fn Callback function for each item         * @param {Object} scope Callback function scope         * @return {Array} results         */                         if ('filter' in Array.prototype) {                return array.filter(fn, scope);            }            var results = [],                i = 0,                ln = array.length;            for (; i < ln; i++) {                if (fn.call(scope, array[i], i, array)) {                    results.push(array[i]);                }            }            return results;        };        utilities.test = {};        utilities.test.isEmpty = function(value, allowEmptyString) {        /**         * Returns true if the passed value is empty, false otherwise. The value is deemed to be empty if it is either:         *         * - `null`         * - `undefined`         * - a zero-length array         * - a zero-length string (Unless the `allowEmptyString` parameter is set to `true`)         *         * @param {Object} value The value to test         * @param {Boolean} allowEmptyString (optional) true to allow empty strings (defaults to false)         * @return {Boolean}         * @markdown         */            return (value === null) || (value === undefined) || (!allowEmptyString ? value === '' : false) || (utilities.test.isArray(value) && value.length === 0);        };        utilities.test.isArray = (function() {        /**         * Returns true if the passed value is a JavaScript Array, false otherwise.         *         * @param {Object} target The target to test         * @return {Boolean}         * @method         */                    return ('isArray' in Array) ?             Array.isArray :             function(value) {                return toString.call(value) === '[object Array]';            }        })();        utilities.test.isDate = function(value) {        /**         * Returns true if the passed value is a JavaScript Date object, false otherwise.         * @param {Object} object The object to test         * @return {Boolean}         */            return toString.call(value) === '[object Date]';        };        utilities.test.isObject = (function() {        /**         * Returns true if the passed value is a JavaScript Object, false otherwise.         * @param {Object} value The value to test         * @return {Boolean}         * @method         */                    return (toString.call(null) === '[object Object]') ?            function(value) {                // check ownerDocument here as well to exclude DOM nodes                return value !== null && value !== undefined && toString.call(value) === '[object Object]' && value.ownerDocument === undefined;            } :            function(value) {                return toString.call(value) === '[object Object]';            };                })();        utilities.test.isPrimitive = function(value) {        /**         * Returns true if the passed value is a JavaScript 'primitive', a string, number or boolean.         * @param {Object} value The value to test         * @return {Boolean}         */                        var type = typeof value;            return type === 'string' || type === 'number' || type === 'boolean';        };        utilities.test.isFunction = (function() {        /**         * Returns true if the passed value is a JavaScript Function, false otherwise.         * @param {Object} value The value to test         * @return {Boolean}         * @method         */            // Safari 3.x and 4.x returns 'function' for typeof <NodeList>, hence we need to fall back to using            // Object.prorotype.toString (slower)            return (typeof document !== 'undefined' && typeof document.getElementsByTagName('body') === 'function') ?             function(value) {                return toString.call(value) === '[object Function]';            } :             function(value) {                return typeof value === 'function';            };                                })();        utilities.test.isNumber = function(value) {        /**         * Returns true if the passed value is a number. Returns false for non-finite numbers.         * @param {Object} value The value to test         * @return {Boolean}         */            return typeof value === 'number' && isFinite(value);        };        utilities.test.isNumeric = function(value) {        /**         * Validates that a value is numeric.         * @param {Object} value Examples: 1, '1', '2.34'         * @return {Boolean} True if numeric, false otherwise         */            return !isNaN(parseFloat(value)) && isFinite(value);        };        utilities.test.isString = function(value) {        /**         * Returns true if the passed value is a string.         * @param {Object} value The value to test         * @return {Boolean}         */            return typeof value === 'string';        };        utilities.test.isBoolean = function(value) {        /**         * Returns true if the passed value is a boolean.         *         * @param {Object} value The value to test         * @return {Boolean}         */            return typeof value === 'boolean';        };        utilities.test.isElement = function(value) {        /**         * Returns true if the passed value is an HTMLElement         * @param {Object} value The value to test         * @return {Boolean}         */            return value ? value.nodeType === 1 : false;        };        utilities.test.isTextNode = function(value) {        /**         * Returns true if the passed value is a TextNode         * @param {Object} value The value to test         * @return {Boolean}         */            return value ? value.nodeName === "#text" : false;        };        utilities.test.isDefined = function(value) {        /**         * Returns true if the passed value is defined.         * @param {Object} value The value to test         * @return {Boolean}         */            return typeof value !== 'undefined';        };        utilities.test.isIterable = function(value) {        /**         * Returns true if the passed value is iterable, false otherwise         * @param {Object} value The value to test         * @return {Boolean}         */            return (value && typeof value !== 'string') ? value.length !== undefined : false;        };                return utilities.init();            }     application.Loader = function(loaderOptions) {                var loader = {};        loader.init = function(loaderOptions) {            return {                loadScript: loader.loadScript            };                    };                loader.getHttpRequest = function() {                        var xmlHttpFactories = [                function () {return new XMLHttpRequest()},                function () {return new ActiveXObject("Msxml2.XMLHTTP")},                function () {return new ActiveXObject("Msxml3.XMLHTTP")},                function () {return new ActiveXObject("Microsoft.XMLHTTP")}            ];            var httpRequest = false;                        for (var i=0; i<xmlHttpFactories.length; i++) {                try {                    httpRequest = xmlHttpFactories[i]();                }                catch (e) {                    continue;                }                break;            }                        if (httpRequest === false) {                throw new Error('This browser does not support XMLHttpRequest.');            }                        return httpRequest;        }        loader.loadScript = function(url, namespace){            var httpRequest = loader.getHttpRequest();            httpRequest.onreadystatechange = function() {                if ( httpRequest.readyState == 4 ) {                                        if (                             httpRequest.status == 200                         ||  httpRequest.status == 304                     ) {                                                  loader.includeJavaScript(                             namespace,                             httpRequest.responseText                         );                                            } else {                                                console.log(                             'XML request error: '                             + httpRequest.statusText                             + ' (' + httpRequest.status + ')'                         ) ;                    }                                    }            }                        httpRequest.open('GET', url, false);            httpRequest.send(null);                    };                loader.includeJavaScript = function(namespace, source) {            if (  source != null  ){                                eval("(" + source + ")(namespace);");                console.log(namespace);            }        }                return loader.init(loaderOptions);            }        return application.init(domains, events);}